// The code in the file is an interface to an ATA (IDE) controller. It attempts to comply to [ATA-3]
// Reference: https://wiki.osdev.org/ATA_PIO_Mode
// Reference: pintos/src/devices/ide.c

#![allow(dead_code)]

use super::super::sync::irq::MutexIrq;
use super::block::{
    BlockDriver, BlockManager, BlockOperations, BlockSector, BlockType, BLOCK_SECTOR_SIZE,
};
use super::partition::partition_scan;
use crate::threading::io::{inb, insw, outb, outsw};
use alloc::vec::Vec;
use alloc::{format, str, string::String};
use core::arch::asm;
use kidneyos_shared::println;
use lazy_static::lazy_static;

// ATA command block port addresses
// Reference: https://wiki.osdev.org/ATA_PIO_Mode#Registers
impl Channel {
    /// R/W Data Register
    ///
    /// Read/Write PIO **data** bytes
    const fn reg_data(&self) -> u16 { self.reg_base }

    /// R   Error Register
    ///
    /// Used to retrieve any error generated by the last ATA command executed.
    const fn reg_error(&self) -> u16 { self.reg_base + 1 }

    /// R/W Sector Count Register
    ///
    /// Number of sectors to read/write (0 is a special value).
    const fn reg_nsect(&self) -> u16 { self.reg_base + 2 }

    /// R/W Sector Number Register (LBAlo)
    ///
    /// This is CHS / LBA28 / LBA48 specific.
    const fn reg_lbal(&self) -> u16 { self.reg_base + 3 }

    /// R/W Cylinder Low Register (LBAmid)
    ///
    /// Partial Disk Sector address.
    const fn reg_lbam(&self) -> u16 { self.reg_base + 4 }

    /// R/W Cylinder High Register (LBAhi)
    ///
    /// Partial Disk Sector address.
    const fn reg_lbah(&self) -> u16 { self.reg_base + 5 }

    /// R   Device / Head Register
    ///
    /// Used to select a drive and/or head. Supports extra address/flag bits.
    const fn reg_device(&self) -> u16 { self.reg_base + 6 }

    /// R   Status Register
    ///
    /// Used to read the current status.
    const fn reg_status(&self) -> u16 { self.reg_base + 7 }

    /// W   Command Register
    ///
    /// Used to send ATA commands to the device.
    const fn reg_command(&self) -> u16 { self.reg_base + 7 }
}

// ATA control block port addresses
// Reference: https://wiki.osdev.org/ATA_PIO_Mode#Registers
impl Channel {
    /// R   Alternate Status Register
    ///
    /// A duplicate of the Status Register which does not affect interrupts.
    const fn reg_alt_status(&self) -> u16 { self.reg_base + 0x206 }

    /// W   Device Control Register
    ///
    /// Used to reset the bus or enable/disable interrupts.
    const fn reg_ctl(&self) -> u16 { self.reg_base + 0x206 }
}

// Alternate Status Register Bits
// Reference: https://wiki.osdev.org/ATA_PIO_Mode#Status_Register_(I/O_base_+_7)

/// Data Request
///
/// Set when the drive has PIO data to transfer, or is ready to accept PIO data.
const STA_DRQ: u8 = 0x08; // Bit 3
/// Device Ready
///
/// Bit is clear when drive is spun down, or after an error. Set otherwise.
const STA_DRDY: u8 = 0x40; // Bit 6
/// Busy
///
/// Indicates the drive is preparing to send/receive data (wait for it to clear). In case of 'hang'
/// (it never clears), do a software reset.
const STA_BSY: u8 = 0x80; // Bit 7

// Control Register bits
// Reference: https://wiki.osdev.org/ATA_PIO_Mode#Device_Control_Register_(Control_base_+_0)

/// Software Reset
///
/// Set, then clear (after 5us), this to do a "Software Reset" on all ATA drives on a bus, if one
/// is misbehaving.
const CTL_SRST: u8 = 0x04; // Bit 2

// Device Register bits

/// Must Be Set
const DEV_MBS: u8 = 0xa0;
/// Linear based addressing
const DEV_LBA: u8 = 0x40;
/// Select device: 0 = master, 1 = slave
const DEV_DEV: u8 = 0x10;

// Commands
// Reference: https://wiki.osdev.org/ATA_Command_Matrix
/// Identify Device
const CMD_IDENTIFY_DEVICE: u8 = 0xec;
/// Read SECTOR with retries
const CMD_READ_SECTOR_RETRY: u8 = 0x20;
/// Write SECTOR with retries
const CMD_WRITE_SECTOR_RETRY: u8 = 0x30;

/// An ATA device
#[derive(Copy, Clone, PartialEq)]
pub struct ATADisk(u8);

impl ATADisk {
    pub fn channel(&self) -> u8 {
        (self.0 / 2) % 2
    }
    pub fn dev_num(&self) -> u8 {
        self.0 % 2
    }
}

impl BlockOperations for ATADisk {
    /// Reads sector SEC_NO from the disk into BUFFER, which must have room for BLOCK_SECTOR_SIZE
    /// bytes.
    ///
    /// Internally synchronizes access to disks, so external per-disk locking is unneeded.
    unsafe fn read(&self, sec_no: BlockSector, buf: &mut [u8]) -> u8 {
        let c: &mut Channel = &mut CHANNELS[self.channel() as usize].lock();
        c.select_sector(self.dev_num(), sec_no);
        c.issue_pio_command(CMD_READ_SECTOR_RETRY);
        c.wait_until_ready();
        c.wait_while_busy();
        c.read_sector(buf);
        0
    }

    /// Write sector SEC_NO to the disk from BUFFER, which must contain BLOCK_SECTOR_SIZE bytes.
    /// Returns after the disk has acknowledged receiving the data.
    ///
    /// Internally synchronizes access to disks, so external per-disk locking is unneeded.
    ///
    /// TODO: double check the lock
    unsafe fn write(&self, sec_no: BlockSector, buf: &[u8]) -> u8 {
        let c: &mut Channel = &mut CHANNELS[self.channel() as usize].lock();
        c.select_sector(self.dev_num(), sec_no);
        c.issue_pio_command(CMD_WRITE_SECTOR_RETRY);
        c.wait_until_ready();
        c.wait_while_busy();
        c.write_sector(buf);
        0
    }
}

/// An ATA channel (aka controller)
///
/// Each channel can control up to two disks
pub struct Channel {
    /// Name, e.g., "ide0"
    name: [u8; 8], // TODO: change to char?
    /// Base I/O port
    reg_base: u16,
    /// Interrupt in use
    irq: u8,

    /// Must acquire to access the controller
    // lock: MutexIrq<Channel>,
    /// True if an interrupt is expected, false if any interrupt would be spurious
    expecting_interrupt: bool,

    /// Up'd by interrupt handler
    // TODO: semaphore?
    // completion_wait: semaphore,

    /// The devices on this channel
    // Master
    d0_name: [u8; 8], // TODO: change to char?
    d0_is_ata: bool,
    // Slave
    d1_name: [u8; 8], // TODO: change to char?
    d1_is_ata: bool,

    channel_num: u8,
}

const CHANNEL_CNT: usize = 2;
lazy_static!(
    static ref CHANNELS: Vec<MutexIrq<Channel>> = {
        (0..CHANNEL_CNT)
        .map(|i| MutexIrq::new(Channel::new(i as u8)))
        .collect()
    };
);

/// Initialize the disk subsystem and detect disks.
///
/// Call with interrupts enabled.
///
/// TODO: review this function
pub fn ide_init(mut all_blocks: BlockManager) -> BlockManager {
    println!("Initialziing ATA driver in PIO mode");

    let mut present: [[bool; 2]; 2] = [[false, false], [false, false]];
    for (i, chan) in CHANNELS.iter().enumerate() {
        let c = &mut chan.lock();
        c.set_names();
        c.reset_channel();
        if c.check_device_type(0) {
            present[i][0] = true;
            present[i][1] = c.check_device_type(1);
        } else {
            println!("IDE: Channel {} device {} has type {}", i, 0, c.is_ata(0));
        }
    }

    for (i, c) in CHANNELS.iter().enumerate() {
        for j in 0..2 {
            if present[i][j] {
                all_blocks = identify_ata_device(c, j as u8, all_blocks);
            } else {
                println!("IDE: Channel {} device {} not present", i, j);
            }
        }
    }

    let mut test_sector: [u8; 512] = [10; 512];
    // TODO: rw test
    test_sector[0] = 2;
    println!("rw test result: {}", test_sector[0] == 10);
    all_blocks
}

impl Channel {
    /// Resets the ATA channel and waits for any devices present on it to finish the reset
    fn reset_channel(&mut self) {
        let mut present: [bool; 2] = [false; 2];

        // The ATA reset sequence depends on which devices are present,
        // so we start by detecting device presence
        for dev_num in 0..2 {
            self.select_device(dev_num);

            outb(self.reg_nsect(), 0x55);
            outb(self.reg_lbal(), 0xaa);

            outb(self.reg_nsect(), 0xaa);
            outb(self.reg_lbal(), 0x55);

            outb(self.reg_nsect(), 0x55);
            outb(self.reg_lbal(), 0xaa);

            present[dev_num as usize] =
                (inb(self.reg_nsect()) == 0x55) && inb(self.reg_lbal()) == 0xaa;
        }

        // Issue soft reset sequence, which selects device 0 as a side effect.
        // Also enable interrupts
        outb(self.reg_ctl(), 0);
        usleep(10); // TODO: use timer
        outb(self.reg_ctl(), CTL_SRST);
        usleep(10); // TODO: use timer
        outb(self.reg_ctl(), 0);

        msleep(150); // TODO: use timer

        // Wait for device 0 to clear BSY
        if present[0] {
            self.select_device(0);
            self.wait_while_busy();
        }
        // Wait for device 1 to clear BSY
        if present[1] {
            self.select_device(1);

            for _ in 0..3000 {
                if inb(self.reg_nsect()) == 1 && inb(self.reg_lbal()) == 1 {
                    break;
                }
                msleep(10); // TODO: use timer
            }
            self.wait_while_busy();
        }
    }

    /// Checks whether device `dev_num` is an ATA disk and set `dev_num`'s is_ata member
    /// appropriately.
    ///
    /// If `dev_num` is device 0 (master), returns true if it's possible that a slave (device 1)
    /// exists on this channel. If `dev_num` is 1 (slave), the return value is not meaningful.
    fn check_device_type(&mut self, dev_num: u8) -> bool {
        self.select_device(dev_num);

        let error: u8 = inb(self.reg_error());
        let lbam: u8 = inb(self.reg_lbam());
        let lbah: u8 = inb(self.reg_lbah());
        let status: u8 = inb(self.reg_status());

        // println!("error: {} status: {}", error, status);

        if (error != 1 && (error != 0x81 || dev_num == 1))
            || (status & STA_DRDY) == 0
            || (status & STA_BSY) != 0
        {
            self.set_is_ata(dev_num, false);
            error != 0x81
        } else {
            self.set_is_ata(
                dev_num,
                (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3),
            );
            true
        }
    }

    /// Selects device `dev_no`, waiting for it to become ready, and then writes SEC_NO to the
    /// disk's selection registers. (We use LBA mode).
    fn select_sector(&self, dev_no: u8, sector: BlockSector) {
        self.select_device_wait(dev_no);
        outb(self.reg_nsect(), 1);
        outb(self.reg_lbal(), sector as u8);
        outb(self.reg_lbam(), (sector >> 8) as u8);
        outb(self.reg_lbah(), (sector >> 16) as u8);
        outb(self.reg_device(),
             DEV_MBS |
                 DEV_LBA |
                 if dev_no == 1 { DEV_DEV } else { 0 } |
                 ((sector >> 24) as u8),
        );
    }

    /// Writes `command` to the channel and prepares for receiving a completion interrupt.
    fn issue_pio_command(&mut self, command: u8) {
        // TODO: assert for interrupt on

        self.expecting_interrupt = true;
        outb(self.reg_command(), command);
    }

    /// Reads a sector from the channel's data register in PIO mode into `buf`, which must have
    /// room for BLOCK_SECTOR_SIZE bytes.
    unsafe fn read_sector(&self, buf: &mut [u8]) {
        let ptr: *mut u8 = buf.as_mut_ptr();
        insw(self.reg_data(), ptr, BLOCK_SECTOR_SIZE / 2);
    }

    /// Writes a sector to the channel's data register in PIO mode from `buf`, which must contain
    /// BLOCK_SECTOR_SIZE bytes.
    unsafe fn write_sector(&mut self, buf: &[u8]) {
        let ptr: *const u8 = buf.as_ptr();
        outsw(self.reg_data(), ptr, BLOCK_SECTOR_SIZE / 2);
    }
}

// Low level ATA primitives
impl Channel {
    /// Wait up to 10 seconds for the channel to become idle, that is, for the BSY and DRQ bits to
    /// clear in the status register.
    ///
    /// As a side effect, reading the status register clears any pending interrupt.
    fn wait_until_ready(&self) {
        for _ in 0..1000 {
            if (inb(self.reg_status()) & (STA_BSY | STA_DRQ)) == 0 {
                return;
            }
            usleep(10); // TODO: use timer
        }

        println!("{} idle timeout", String::from_utf8_lossy(&self.name));
    }

    /// Wait up to 30 seconds for the channel to clear BSY, and then return the status of the DRQ
    /// bit.
    ///
    /// The ATA standards say that a disk may take as long as that to complete its reset.
    fn wait_while_busy(&self) -> bool {
        for i in 0..3000 {
            if i == 700 { println!("{} busy, waiting...", String::from_utf8_lossy(&self.name)); }

            if (inb(self.reg_alt_status()) & STA_BSY) == 0 {
                if i >= 700 { println!("{} ok", String::from_utf8_lossy(&self.name)); }
                return (inb(self.reg_alt_status()) & STA_DRQ) != 0;
            }
            usleep(10); // TODO: use timer
        }

        println!("failed"); // TODO: panic?
        false
    }

    /// Program the channel so that `dev_num` is now the selected disk.
    fn select_device(&self, dev_num: u8) {
        let mut dev: u8 = DEV_MBS;
        if dev_num == 1 { dev |= DEV_DEV; }

        outb(self.reg_device(), dev);
        inb(self.reg_alt_status());
        nsleep(400); // TODO: use timer
    }

    /// Select disk `dev_num`, as [`Channel::select_device`], but wait for the channel to become
    /// idle before and after.
    fn select_device_wait(&self, dev_num: u8) {
        self.wait_until_ready();
        self.select_device(dev_num);
        self.wait_until_ready();
    }
}

/// Sends an IDENTIFY DEVICE command to disk `dev_no` and reads the response. Registers the disk
/// with the block device layer.
///
/// TODO: review this function
fn identify_ata_device(
    channel: &'static MutexIrq<Channel>,
    dev_no: u8,
    mut all_blocks: BlockManager,
) -> BlockManager {
    let capacity: usize;
    let name: String;
    let idx: usize;
    {
        let c: &mut Channel = &mut channel.lock();
        let mut id: [u8; BLOCK_SECTOR_SIZE] = [0; BLOCK_SECTOR_SIZE];

        // Send the IDENTIFY DEVICE command, wait for an interrupt indicating the device's response
        // is ready, and read the data into our buffer.
        c.select_device_wait(dev_no);
        c.issue_pio_command(CMD_IDENTIFY_DEVICE);
        // self.wait_until_ready();
        // semaphore down

        if !c.wait_while_busy() {
            c.set_is_ata(dev_no, false);
            // println!("channel {} device {} is not ata", c.channel_num, dev_no);
            return all_blocks;
        }
        unsafe { c.read_sector(&mut id); }

        // Calculate capacity.
        capacity = usize::from_le_bytes(id[120..124].try_into().unwrap());
        name = parse_cstr(&if dev_no == 0 { c.d0_name } else { c.d1_name }).into();
        println!("channel: {} device: {} name: {} capacity: {}M",
                 c.channel_num, dev_no, &name, capacity >> 11);

        // Register
        let d: BlockDriver = BlockDriver::ATAPio(ATADisk(c.channel_num * 2 + dev_no));
        idx = all_blocks.block_register(BlockType::Raw, name, capacity as BlockSector, d);
    }
    all_blocks = partition_scan(idx, all_blocks);
    all_blocks
}

fn msleep(t: usize) {
    for _ in 0..9 {
        usleep(t);
    }
}
fn usleep(t: usize) {
    for _ in 0..9 * t {
        nsleep(t);
    }
}
fn nsleep(_t: usize) {
    unsafe {
        asm!("nop");
    }
}

fn byte_enumerator(s: String) -> impl Iterator<Item=(usize, u8)> {
    s.into_bytes().into_iter().enumerate()
}

fn parse_cstr(buf: &[u8]) -> &str {
    let mut l = 0;
    for c in buf {
        if *c == 0 {
            break;
        }
        l += 1;
    }
    str::from_utf8(&buf[0..l]).unwrap()
}

impl Channel {
    /* ATA command block port addresses */
    const fn new(channel_num: u8) -> Channel {
        let name: [u8; 8] = [0; 8];
        let reg_base = match channel_num {
            0 => 0x1f0,
            1 => 0x170,
            _ => panic!(),
        };
        let irq = match channel_num {
            0 => 14 + 0x20,
            1 => 15 + 0x20,
            _ => panic!(),
        };
        //initialize disks
        let d0_name: [u8; 8] = [0; 8];
        let d1_name: [u8; 8] = [0; 8];
        Channel {
            name,
            reg_base,
            irq,
            expecting_interrupt: false,
            d0_name,
            d0_is_ata: false,
            d1_name,
            d1_is_ata: false,
            channel_num,
        }
    }

    /// Sets the name, d0_name, and d1_name members of the `dev_no` disk to the appropriate values.
    fn set_names(&mut self) {
        for (j, c) in byte_enumerator(format!("ide{}zu\0", self.channel_num)) {
            self.name[j] = c;
        }
        for (j, c) in byte_enumerator(format!("hd{}\0", (0x61 + self.channel_num * 2) as char)) {
            self.d0_name[j] = c;
        }
        for (j, c) in byte_enumerator(format!("hd{}\0", (0x61 + 1 + self.channel_num * 2) as char))
        {
            self.d1_name[j] = c;
        }
    }

    /// Sets the is_ata member of the `dev_no` disk to `is_ata`.
    fn set_is_ata(&mut self, dev_no: u8, is_ata: bool) {
        if dev_no == 0 {
            self.d0_is_ata = is_ata;
        } else if dev_no == 1 {
            self.d1_is_ata = is_ata;
        } else {
            panic!("{}.set_is_ata: invalid dev_no ({})",
                   String::from_utf8_lossy(&self.name), dev_no);
        }
    }

    /// Returns true if the `dev_no` disk is an ATA disk, false if it is not present or not an ATA
    /// disk.
    fn is_ata(&self, dev_no: u8) -> bool {
        if dev_no == 0 {
            self.d0_is_ata
        } else if dev_no == 1 {
            self.d1_is_ata
        } else {
            false
        }
    }
}

#[naked]
pub unsafe extern "C" fn ide_interrupt_handler() -> ! {
    fn inner() {
        for chan in CHANNELS.iter() {
            if true { // TODO: compare interrupt vector number with chan.irq
                let c = &mut chan.lock();

                if c.expecting_interrupt {
                    inb(c.reg_status());
                    // semaphore up
                } else {
                    panic!("{}: unexpected interrupt", String::from_utf8_lossy(&c.name));
                }
            }
        }
    }

    asm!(
    "call {}",
    sym inner,
    options(noreturn),
    )
}

