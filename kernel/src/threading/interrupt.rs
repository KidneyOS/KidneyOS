// Programmable Interrupt Controller (PIC)
// Reference: https://wiki.osdev.org/8259_PIC
// Reference: pintos/src/threads/interrupt.h/.c

// PIC registers.
//  A PIC has two PICs, called the master and slave PICs, with the slave attached ("cascaded") to
// the master IRQ line 2.
// Reference: https://wiki.osdev.org/8259_PIC#Programming_with_the_8259_PIC

#![allow(dead_code)] // Suppress unused warnings

use crate::println;
use crate::threading::intr_stubs::INTR_STUBS;
use crate::threading::loader::SEL_KCSEG;
use core::arch::asm;

/// Master PIC - Command
const PIC0_CTRL: u16 = 0x20;
/// Master PIC - Data
const PIC0_DATA: u16 = 0x21;
/// Slave PIC - Command
const PIC1_CTRL: u16 = 0xA0;
/// Slave PIC - Data
const PIC1_DATA: u16 = 0xA1;

/// Number of x86 interrupt vectors.
const INTR_CNT: usize = 256;

// TODO: push registers in stub
#[repr(C)]
pub struct IntrFrame {
    /// Saved EDI
    edi: u32,
    /// Saved ESI
    esi: u32,
    /// Saved EBP
    ebp: u32,
    /// Not used
    esp_dummy: u32,

    /// Saved EBX
    ebx: u32,
    /// Saved EDX
    edx: u32,
    /// Saved ECX
    ecx: u32,
    /// Saved EAX
    eax: u32,

    /// Saved GS segment register
    gs: u16,
    /// Saved FS segment register
    fs: u16,
    /// Saved ES segment register
    es: u16,
    /// Saved DS segment register
    ds: u16,

    /// Interrupt vector number
    vec_no: u32,

    /// Error code
    error_code: u32,

    /// Saved frame pointer (EBP)
    frame_pointer: *mut core::ffi::c_void,

    /// Next instruction to execute
    eip: extern "C" fn() -> (),
    /// Code segment for eip
    cs: u16,
    /// Saved CPU flags
    eflags: u32,
    /// Saved stack pointer
    esp: *mut core::ffi::c_void,
    /// Data segment for esp
    ss: u16,
}

pub type IntrHandlerFunc = fn(frame: &IntrFrame);

/// Programmable Interrupt Controller (PIC)
pub struct Pic {
    /// The Interrupt Descriptor Table (IDT).  The format is fixed by the CPU.  See [IA32-v3a]
    /// sections 5.10 "Interrupt Descriptor Table (IDT)", 5.11 "IDT Descriptors", 5.12.1.2 "Flag
    /// Usage By Exception- or Interrupt-Handler Procedure".
    idt: [u64; INTR_CNT],

    /// Interrupt handler functions for each interrupt.
    handlers: [Option<IntrHandlerFunc>; INTR_CNT],

    /// Names for each interrupt, for debugging purposes.
    intr_names: [&'static str; INTR_CNT],

    /// Number of unexpected interrupts for each vector.  An unexpected interrupt is one that has no
    /// registered handler.
    unexpected_cnt: [u32; INTR_CNT],

    // External interrupts are those generated by devices outside the CPU, such as the timer. External
    // interrupts run with interrupts turned off, so they never nest, nor are they ever pre-empted.
    // Handlers for external interrupts also may not sleep, although they may invoke
    // intr_yield_on_return() to request that a new process be scheduled just before the interrupt
    // returns.
    /// Whether the current interrupt is an external interrupt.
    in_external_intr: bool,
    /// Whether to yield on return from the current interrupt.
    yield_on_return: bool,
}

/// Initializes the interrupt system.
pub unsafe fn init_intr() -> Pic {
    // Initialize interrupt controller
    let mut pic: Pic = pic_init();

    // Initialize IDT
    for (i, &stub) in INTR_STUBS.iter().enumerate() {
        pic.idt[i] = pic.make_intr_gate(stub, 0);
    }

    // Load IDT register.
    // See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt Descriptor Table (IDT)".
    let idtr_operand = make_idtr_operand(
        (pic.idt.len() * core::mem::size_of::<u64>() - 1) as u16,
        pic.idt.as_ptr(),
    );
    asm!("lidt [{0}]", in(reg) &idtr_operand);

    // Initialize interrupt names.
    for i in 0..INTR_CNT {
        pic.intr_names[i] = "unknown";
    }
    pic.intr_names[0] = "#DE Divide Error";
    pic.intr_names[1] = "#DB Debug Exception";
    pic.intr_names[2] = "NMI Interrupt";
    pic.intr_names[3] = "#BP Breakpoint Exception";
    pic.intr_names[4] = "#OF Overflow Exception";
    pic.intr_names[5] = "#BR BOUND Range Exceeded Exception";
    pic.intr_names[6] = "#UD Invalid Opcode Exception";
    pic.intr_names[7] = "#NM Device Not Available Exception";
    pic.intr_names[8] = "#DF Double Fault Exception";
    pic.intr_names[9] = "Coprocessor Segment Overrun";
    pic.intr_names[10] = "#TS Invalid TSS Exception";
    pic.intr_names[11] = "#NP Segment Not Present";
    pic.intr_names[12] = "#SS Stack Fault Exception";
    pic.intr_names[13] = "#GP General Protection Exception";
    pic.intr_names[14] = "#PF Page-Fault Exception";
    pic.intr_names[16] = "#MF x87 FPU Floating-Point Error";
    pic.intr_names[17] = "#AC Alignment Check Exception";
    pic.intr_names[18] = "#MC Machine-Check Exception";
    pic.intr_names[19] = "#XF SIMD Floating-Point Exception";

    pic
}

impl Pic {
    /// Returns true if interrupts are enabled, false otherwise.
    pub fn get_intr_enabled(&self) -> bool {
        let flags: u32;

        // Push the flags register on the processor stack, then pop the value off the stack into
        // `flags'.  See [IA32-v2b] "PUSHF" and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
        // Interrupts"
        unsafe {
            asm!("pushf; pop {0}", out(reg) flags);
        }

        flags & 0x200 != 0
    }

    /// Enables or disables interrupts as specified by `enable'.
    ///
    /// Returns the previous interrupt state.
    pub fn set_intr_enabled(&self, level: bool) -> bool {
        if level {
            self.iter_enable()
        } else {
            self.intr_disable()
        }
    }

    /// Enables interrupts and returns the previous interrupt state.
    pub fn iter_enable(&self) -> bool {
        let old_level = self.get_intr_enabled();
        assert!(!self.intr_context());

        unsafe {
            asm!("sti");
        }
        old_level
    }

    /// Disables interrupts and returns the previous interrupt status
    pub fn intr_disable(&self) -> bool {
        let old_level = self.get_intr_enabled();

        // Disable interrupts by clearing the interrupt flag. See [IA32-v2b] "CLI" and [IA32-v3a]
        // 5.8.1 "Masking Maskable Hardware Interrupts".
        unsafe {
            asm!("cli", options(nostack, preserves_flags));
        }

        old_level
    }
    fn register_handler(
        &mut self,
        vec_no: u8,
        dpl: u8,
        level: bool,
        handler: IntrHandlerFunc,
        name: &'static str,
    ) {
        if level {
            unsafe {
                self.idt[vec_no as usize] = self.make_trap_gate(INTR_STUBS[vec_no as usize], dpl);
            }
        } else {
            unsafe {
                self.idt[vec_no as usize] = self.make_intr_gate(INTR_STUBS[vec_no as usize], dpl);
            }
        }

        self.handlers[vec_no as usize] = Some(handler);
        self.intr_names[vec_no as usize] = name;
    }

    /// Registers external interrupt VEC_NO to invoke HANDLER, which is named NAME for debugging
    /// purposes. The handler will execute with interrupts disabled.
    pub fn intr_register_ext(&mut self, vec_no: u8, handler: IntrHandlerFunc, name: &'static str) {
        self.register_handler(vec_no, 0, true, handler, name);
    }

    /// Registers internal interrupt `vec_no` to invoke HANDLER, which is named `name` for debugging
    /// purposes. The interrupt handler will be invoked with interrupt status `level`.
    ///
    /// The handler will have descriptor privilege level `dpl`, meaning that it can be invoked
    /// intentionally when the processor is in the `dpl` or lower-numbered ring.  In practice, `dpl==3`
    /// allows user mode to invoke the interrupts and `dpl==0` prevents such invocation. Faults and
    /// exceptions that occur in user mode still cause interrupts with `dpl==0` to be invoked. See
    /// [IA32-v3a] sections 4.5 "Privilege Levels" and 4.8.1.1 "Accessing Nonconforming Code Segments"
    /// for further discussion.
    pub fn intr_register_int(
        &mut self,
        vec_no: u8,
        _dpl: u8,
        _level: bool,
        handler: IntrHandlerFunc,
        name: &'static str,
    ) {
        assert!(vec_no < 0x20 || vec_no == 0x2f);

        self.register_handler(vec_no, 0, false, handler, name);
    }

    /// Returns true during processing of an external interrupt and false at all other times.
    pub fn intr_context(&self) -> bool {
        self.in_external_intr
    }

    /// During processing of an external interrupt, directs the interrupt handler to yield to a new
    /// process just before returning from the interrupt. May not be called at any other time.
    pub fn intr_yield_on_return(&mut self) {
        assert!(self.intr_context());

        self.yield_on_return = true;
    }
}

/* 8259A Programmable Interrupt Controller. */
impl Pic {
    fn pic_end_of_interrupt(&self, irq: u8) {
        assert!((0x20..0x30).contains(&irq));

        // Acknowledge master PIC.
        outb(0x20, 0x20);

        // Acknowledge slave PIC if this is a slave interrupt.
        if irq >= 0x28 {
            outb(0xa0, 0x20);
        }
    }

    /// Creates a gate that invokes `function`.
    ///
    /// The gate has descriptor privilege level `dpl`, meaning that it can be invoked intentionally
    /// when the processor is in the `dpl` or lower-numbered ring.  In practice, `dpl==3` allows
    /// user mode to call into the gate and `dpl==0` prevents such calls. Faults and exceptions that
    /// occur in user mode still cause gates with `dpl==0` to be invoked. See [IA32-v3a] sections
    /// 4.5 "Privilege Levels" and 4.8.1.1 "Accessing Nonconforming Code Segments" for further
    /// discussion.
    ///
    /// `gate_type` must be either 14 (for an interrupt gate) or 15 (for a trap gate). The
    /// difference is that entering an interrupt gate disables interrupts, but entering a trap gate
    /// does not. See [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or Interrupt-Handler
    /// Procedure" for discussion.
    fn make_gate(&self, function: fn() -> (), dpl: u8, gate_type: u8) -> u64 {
        // Assert function != null
        // assert!(dpl >= 0 && dpl <= 3);
        // assert!(gate_type >= 0 && gate_type <= 15);
        assert!(dpl <= 3); // dpl is a u8 so it can't be negative
        assert!(gate_type <= 15); // gate_type is a u8 so it can't be negative

        let e0 = (function as usize) as u32 & 0xffff  // offset 15:0
            | (SEL_KCSEG as u32) << 16; // Target code segment
        let e1 = (function as usize) as u32 & 0xffff0000 // offset 31:16
            | (1 << 15) // present
            | (dpl as u32) << 13 // Descriptor privilege level
            | (1 << 12) // System
            | (gate_type as u32) << 8; // type

        (e0 as u64) | ((e1 as u64) << 32)
    }

    /// Creates an interrupt gate that invokes `function` with the given `dpl`.
    fn make_intr_gate(&self, function: fn() -> (), dpl: u8) -> u64 {
        self.make_gate(function, dpl, 14)
    }

    /// Creates a trap gate that invokes `function` with the given `dpl`.
    fn make_trap_gate(&self, function: fn() -> (), dpl: u8) -> u64 {
        self.make_gate(function, dpl, 15)
    }

    fn intr_handler(&mut self, frame: &IntrFrame) {
        let external = frame.vec_no >= 0x20 && frame.vec_no < 0x30;
        if external {
            assert!(!self.get_intr_enabled());
            assert!(!self.intr_context());

            self.in_external_intr = true;
            self.yield_on_return = false;
        }

        // Invoke the interupt's handler
        let handler = self.handlers[frame.vec_no as usize];
        if let Some(handler) = handler {
            // Handler is registered, invoke it
            handler(frame);
        } else if frame.vec_no == 0x27 || frame.vec_no == 0x2f {
            // From PintOS:
            // There is no handler, but this interrupt can trigger
            // spuriously due to a hardware fault or hardware race
            // condition.  Ignore it. */
            // TODO: verify if this is true
        } else {
            self.unexpected_interrupt(frame);
        }

        // Complete the processing of an external interrupt
        if external {
            assert!(!self.get_intr_enabled());
            assert!(self.intr_context());

            self.in_external_intr = false;
            self.pic_end_of_interrupt(frame.vec_no as u8);

            if self.yield_on_return {
                // TODO: thread_yield()
            }
        }
    }

    fn unexpected_interrupt(&mut self, frame: &IntrFrame) {
        self.unexpected_cnt[frame.vec_no as usize] += 1;
        let n = self.unexpected_cnt[frame.vec_no as usize];
        if (n & (n - 1)) == 0 {
            // Print a message every time the count doubles.
            println!(
                "Unexpected interrupt {:#04x} ({}).",
                frame.vec_no, self.intr_names[frame.vec_no as usize]
            );
        }
    }
}

impl Pic {
    fn new() -> Self {
        Pic {
            idt: [0; INTR_CNT],
            handlers: [None; INTR_CNT],
            intr_names: ["unknown"; INTR_CNT],
            unexpected_cnt: [0; INTR_CNT],
            in_external_intr: false,
            yield_on_return: false,
        }
    }
}

/// Initializes the PICs.  Refer to [8259A] for details.
///
/// By default, interrupts 0...15 delivered by the PICs will go to interrupt vectors 0...15.
/// Those vectors are also used for CPU traps and exceptions, so we reprogram the PICs so that
/// interrupts 0...15 are delivered to interrupt vectors 32...47 (0x20...0x2f) instead.
fn pic_init() -> Pic {
    let pic = Pic::new();
    // TODO: use [`threading::io::outb`] instead

    // Mask all interrupts on both PICs.
    outb(PIC0_DATA, 0xff);
    outb(PIC1_DATA, 0xff);

    // Initialize master.
    outb(PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
    outb(PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
    outb(PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
    outb(PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */

    // Initialize slave.
    outb(PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
    outb(PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
    outb(PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
    outb(PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */

    // Unmask all interrupts.
    outb(PIC0_DATA, 0x00);
    outb(PIC1_DATA, 0x00);

    pic
}

/// Returns a descriptor that yields the given `limit` and `base` when used as an operand for
/// the LIDT instruction.
fn make_idtr_operand(limit: u16, base: *const u64) -> u64 {
    (limit as u64) | ((base as u64) << 16)
}

/// TODO: use [`threading::io::outb`] instead
fn outb(port: u16, data: u8) {
    unsafe {
        asm!(
        "outb %al, %dx",
        in("al") data,
        in("dx") port,
        options(att_syntax)
        );
    }
}
